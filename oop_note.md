# OOP Notes
函数封装的是语句，类封装的是相关函数以及数据

类命名：多单词首字符大写
变量命名：小写字母+下划线

函数名就是变量名，类名是标识符?

类下的函数：方法

规范上：类属性放在前面，实际上没有语法要求
创建类的对象的过程：实例化

实例对象通过点调用类属性和方法
用print(id(比较存储数据的内存位置))

## 实例属性
个体的差异叫做实例属性，共有的一样的叫做类属性
直接在实例对象的控件定义变量，赋值

访问顺序：实例空间、类空间、父类空间

## 实例方法和self
定义的函数：实例方法的第一个形参是自己本身，因为方法一般都会应用在自己身上。该形参一般叫做self，但是设置什么都行

self永远不用传，调用的时候第一个实参会自动传给第二个形参！

实例属性在__init__中定义，可以在构造中定义实例属性！

## 一切皆对象

例如：字符串str("hello world") 简写"hello world"用type(str("hello world"))获取类名str
字符串的操作就是str类的实例方法

列表对象list()......

字典对象dict()......

任何一个实例对象，都有一个属于的类型；自定义类型对象属于可变数据类型。什么是不可变数据类型？

实例对象都是一等公民，可以作为变量传参、函数返回值。

变量传递不开辟新的空间，和不可变数据类型有什么关系？

函数传参就是变量传递，只读。

可变数据类型就是函数内部可以操作函数外面的变量？

## 类对象、类属性、类方法
### 类对象

通过类对象调用类的共有属性: Car.total_number
在__init__中增加total_number，每一次实例化，都会改变类的共有属性。
改变时，类名调用类方法，类名用self.__class__，这样类中不含有类名！

### 类方法

对类的共有属性、操作的方法：
@classmethod下面紧跟的函数是类方法，什么都没有默认是实例方法，因为实际使用时99%都是实例方法。
第一个参数cls代指调用的类名，类中不含有类名，cls代指调用类方法的类
使用类方法不用经过某个实例空间。

## 静态方法

@staticmethod既不依赖于某个类，也不依赖于某个实例对象
只需要相关功能的函数封装在一起，做一个统一的管理。
例如加法、减法等等...

调用：通过1实例对象或2类对象进行调用，不会再把调用对象传参。
主要：通过类对象调用Cal.plus(x,y)==x+y

# 类继承

## 类继承的初始化

调用父类初始化函数，和父类的初始化参数
